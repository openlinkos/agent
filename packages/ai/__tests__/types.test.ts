/**
 * Tests for type validation helpers and createModel factory.
 */

import { describe, it, expect, beforeEach } from "vitest";
import {
  createModel,
  registerProvider,
  clearProviders,
} from "../src/index.js";
import type { ModelProvider, ProviderRequestOptions } from "../src/provider.js";
import type { Message, ModelResponse, ModelCapabilities, ToolDefinition } from "../src/types.js";
import type { StreamResult } from "../src/stream.js";
import { streamFromArray } from "../src/stream.js";

// ---------------------------------------------------------------------------
// Mock provider
// ---------------------------------------------------------------------------

function createTestProvider(): ModelProvider {
  const capabilities: ModelCapabilities = {
    streaming: true,
    toolCalling: true,
    structuredOutput: true,
    systemMessages: true,
    vision: false,
  };

  return {
    name: "test",
    capabilities,
    async generate(messages: Message[], options: ProviderRequestOptions): Promise<ModelResponse> {
      return {
        text: `Generated by ${options.modelName}`,
        toolCalls: [],
        usage: { promptTokens: 10, completionTokens: 20, totalTokens: 30 },
        finishReason: "stop",
      };
    },
    async stream(_messages: Message[], options: ProviderRequestOptions): Promise<StreamResult> {
      return streamFromArray([
        { type: "text_delta", text: `Streamed by ${options.modelName}` },
        { type: "usage", usage: { promptTokens: 5, completionTokens: 10, totalTokens: 15 } },
        { type: "done" },
      ]);
    },
    async generateWithTools(messages: Message[], tools: ToolDefinition[], options: ProviderRequestOptions): Promise<ModelResponse> {
      return {
        text: `Tools available: ${tools.map((t) => t.name).join(", ")}`,
        toolCalls: tools.length > 0 ? [{
          id: "call_1",
          name: tools[0].name,
          arguments: { test: true },
        }] : [],
        usage: { promptTokens: 15, completionTokens: 25, totalTokens: 40 },
        finishReason: "tool_calls",
      };
    },
  };
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

describe("createModel", () => {
  beforeEach(() => {
    clearProviders();
    registerProvider(createTestProvider());
  });

  it("should create a model with valid identifier", () => {
    const model = createModel("test:my-model");
    expect(model.modelId).toBe("test:my-model");
  });

  it("should throw for invalid identifier", () => {
    expect(() => createModel("invalid")).toThrow("Invalid model identifier");
  });

  it("should generate responses through the provider", async () => {
    const model = createModel("test:gpt-4o");
    const response = await model.generate([
      { role: "user", content: "Hello!" },
    ]);
    expect(response.text).toBe("Generated by gpt-4o");
    expect(response.finishReason).toBe("stop");
    expect(response.usage.totalTokens).toBe(30);
  });

  it("should stream responses through the provider", async () => {
    const model = createModel("test:claude-3");
    const stream = await model.stream([
      { role: "user", content: "Hello!" },
    ]);

    const events = [];
    for await (const event of stream) {
      events.push(event);
    }

    expect(events.length).toBe(3);
    expect(events[0]).toEqual({ type: "text_delta", text: "Streamed by claude-3" });
  });

  it("should generate with tools", async () => {
    const model = createModel("test:gpt-4o");
    const tools: ToolDefinition[] = [
      {
        name: "calculator",
        description: "Perform math",
        parameters: { type: "object", properties: { expression: { type: "string" } } },
      },
    ];

    const response = await model.generateWithTools(
      [{ role: "user", content: "Calculate 2+2" }],
      tools,
    );
    expect(response.text).toBe("Tools available: calculator");
    expect(response.toolCalls).toHaveLength(1);
    expect(response.toolCalls[0].name).toBe("calculator");
  });

  it("should merge config overrides", async () => {
    const model = createModel("test:base-model", { temperature: 0.5 });
    // The override should work â€” we trust the mock provider received it
    const response = await model.generate(
      [{ role: "user", content: "test" }],
      { temperature: 0.9 },
    );
    expect(response.text).toBe("Generated by base-model");
  });

  it("should throw when provider not registered", async () => {
    const model = createModel("nonexistent:model");
    await expect(
      model.generate([{ role: "user", content: "test" }]),
    ).rejects.toThrow('Provider "nonexistent" is not registered');
  });
});

describe("Message types", () => {
  it("should accept system messages", () => {
    const msg: Message = { role: "system", content: "You are helpful." };
    expect(msg.role).toBe("system");
  });

  it("should accept user messages", () => {
    const msg: Message = { role: "user", content: "Hello!" };
    expect(msg.role).toBe("user");
  });

  it("should accept assistant messages with tool calls", () => {
    const msg: Message = {
      role: "assistant",
      content: "I'll help with that.",
      toolCalls: [
        { id: "call_1", name: "search", arguments: { query: "test" } },
      ],
    };
    expect(msg.role).toBe("assistant");
    if (msg.role === "assistant") {
      expect(msg.toolCalls).toHaveLength(1);
    }
  });

  it("should accept tool messages", () => {
    const msg: Message = {
      role: "tool",
      toolCallId: "call_1",
      content: "Search results...",
    };
    expect(msg.role).toBe("tool");
    if (msg.role === "tool") {
      expect(msg.toolCallId).toBe("call_1");
    }
  });
});
